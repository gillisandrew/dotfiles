#!/usr/bin/env bash

set -euo pipefail

# --- gum helpers ---
has_gum() { command -v gum >/dev/null 2>&1; }
log_info()  { if has_gum; then gum log --level info  "$@"; else echo "[INFO]  $*"; fi; }
log_warn()  { if has_gum; then gum log --level warn  "$@"; else echo "[WARN]  $*"; fi; }

confirm_or_force() {
  local prompt="$1"
  if [[ "$FORCE" == true ]]; then return 0; fi
  if has_gum && [[ -t 0 ]]; then gum confirm "$prompt"; return $?; fi
  return 1
}

spin() {
  local title="$1"; shift
  if has_gum && [[ -t 1 ]]; then
    gum spin --spinner dot --title "$title" -- "$@"
  else
    echo "$title"; "$@"
  fi
}

FORCE=false
if [[ "${1:-}" == "--force" ]]; then
  FORCE=true
fi

# --- Prefer kondo when available ---
if command -v kondo >/dev/null 2>&1; then
  if [[ "$FORCE" == true ]]; then
    kondo --all
  else
    kondo
  fi
  exit $?
fi

# --- Fallback: find-based cleanup ---
log_info "kondo not found, using built-in cleanup"

# Directories commonly safe to delete
TARGET_DIRS=(
  "node_modules"
  "dist"
  "build"
  ".next"
  ".nuxt"
  ".cache"
  ".parcel-cache"
  ".terraform"
  ".venv"
  "venv"
  "__pycache__"
  ".pytest_cache"
  ".mypy_cache"
  ".tox"
  ".gradle"
  "target"
  "coverage"
)

# Build find expression dynamically
FIND_EXPR=()
for dir in "${TARGET_DIRS[@]}"; do
  FIND_EXPR+=( -name "$dir" -o )
done

# Remove trailing -o
unset 'FIND_EXPR[${#FIND_EXPR[@]}-1]'

# Collect all matching paths into an array
FOUND_PATHS=()
while IFS= read -r -d '' path; do
  FOUND_PATHS+=("$path")
done < <(
  find . \
    -type d \
    \( "${FIND_EXPR[@]}" \) \
    -not -path "*/.git/*" \
    -print0
)

if [[ ${#FOUND_PATHS[@]} -eq 0 ]]; then
  log_info "No matching directories found."
  exit 0
fi

# Show what was found
for path in "${FOUND_PATHS[@]}"; do
  log_info "Found: $path"
done

log_info "Total: ${#FOUND_PATHS[@]} directories"

if confirm_or_force "Delete ${#FOUND_PATHS[@]} directories?"; then
  for path in "${FOUND_PATHS[@]}"; do
    spin "Removing $path..." rm -rf "$path"
  done
  log_info "Cleanup complete."
else
  log_info "Dry run complete. Re-run with --force to delete."
fi
