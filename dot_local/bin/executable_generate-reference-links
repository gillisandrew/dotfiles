#!/bin/bash

# generate-reference-links - Generate reference-style link definitions for GitHub compatibility
# Usage: generate-reference-links [file.md|directory]
# Scans for [[internal links]] and generates corresponding [link]: path definitions

# --- gum helpers ---
has_gum() { command -v gum >/dev/null 2>&1; }
log_info()  { if has_gum; then gum log --level info  "$@"; else echo "[INFO]  $*"; fi; }
log_warn()  { if has_gum; then gum log --level warn  "$@"; else echo "[WARN]  $*"; fi; }

process_file() {
    local file="$1"
    local temp_file="${file}.tmp"
    
    # Extract all [[internal links]] from the file
    local internal_links
    internal_links=$(grep -o '\[\[[^]]*\]\]' "$file" | sed 's/\[\[\([^]]*\)\]\]/\1/' | sort -u)
    
    if [[ -z "$internal_links" ]]; then
        log_info "No internal links found in $file"
        return 0
    fi
    
    # Check if reference section already exists
    local has_reference_section=false
    if grep -q "^<!-- Auto-generated reference-style links -->" "$file"; then
        has_reference_section=true
    fi
    
    # Determine base directory for relative path resolution
    local base_dir
    if [[ "$file" == drafts/* ]]; then
        base_dir="drafts"
    elif [[ "$file" == notes/* ]]; then
        base_dir="notes"
    elif [[ "$file" == reports/* ]]; then
        base_dir="reports"
    else
        base_dir="."
    fi
    
    # Build reference definitions by checking where files actually exist
    local reference_definitions=""
    while IFS= read -r link_text; do
        [[ -z "$link_text" ]] && continue
        
        # URL encode the filename (spaces become %20)
        local encoded_filename="${link_text// /%20}"
        local relative_path=""
        
        # Check where the target file actually exists and determine correct relative path
        if [[ -f "notes/${link_text}.md" ]]; then
            # File exists in notes directory
            case "$base_dir" in
                "drafts") relative_path="../notes/${encoded_filename}.md" ;;
                "notes") relative_path="./${encoded_filename}.md" ;;
                "reports") relative_path="../notes/${encoded_filename}.md" ;;
                *) relative_path="notes/${encoded_filename}.md" ;;
            esac
        elif [[ -f "drafts/${link_text}.md" ]]; then
            # File exists in drafts directory
            case "$base_dir" in
                "drafts") relative_path="./${encoded_filename}.md" ;;
                "notes") relative_path="../drafts/${encoded_filename}.md" ;;
                "reports") relative_path="../drafts/${encoded_filename}.md" ;;
                *) relative_path="drafts/${encoded_filename}.md" ;;
            esac
        elif [[ -f "reports/${link_text}.md" ]]; then
            # File exists in reports directory
            case "$base_dir" in
                "drafts") relative_path="../reports/${encoded_filename}.md" ;;
                "notes") relative_path="../reports/${encoded_filename}.md" ;;
                "reports") relative_path="./${encoded_filename}.md" ;;
                *) relative_path="reports/${encoded_filename}.md" ;;
            esac
        else
            # File doesn't exist yet - assume it will be in drafts (common workflow)
            log_warn "Target file '${link_text}.md' not found, assuming drafts directory"
            case "$base_dir" in
                "drafts") relative_path="./${encoded_filename}.md" ;;
                "notes") relative_path="../drafts/${encoded_filename}.md" ;;
                "reports") relative_path="../drafts/${encoded_filename}.md" ;;
                *) relative_path="drafts/${encoded_filename}.md" ;;
            esac
        fi
        
        local reference_line="[${link_text}]: ${relative_path}"
        
        if [[ -z "$reference_definitions" ]]; then
            reference_definitions="$reference_line"
        else
            reference_definitions="${reference_definitions}
$reference_line"
        fi
    done <<< "$internal_links"
    
    # Create new file content
    if [[ "$has_reference_section" == true ]]; then
        # Replace content between start and end markers
        awk '
        BEGIN { in_section = 0; print_buffer = "" }
        /^<!-- Auto-generated reference-style links -->/ { 
            in_section = 1
            print "<!-- Auto-generated reference-style links -->"
            print ""
            while ((getline ref_line < "/dev/stdin") > 0) {
                print ref_line
            }
            print ""
            print "<!-- End auto-generated reference-style links -->"
            next
        }
        /^<!-- End auto-generated reference-style links -->/ { 
            in_section = 0
            next
        }
        !in_section { print }
        ' "$file" <<< "$reference_definitions" > "$temp_file"
    else
        # Add new reference section at end
        cp "$file" "$temp_file"
        
        # Add reference section with both markers
        echo "<!-- Auto-generated reference-style links -->" >> "$temp_file"
        echo "" >> "$temp_file"
        echo "$reference_definitions" >> "$temp_file"
        echo "" >> "$temp_file"
        echo "<!-- End auto-generated reference-style links -->" >> "$temp_file"
    fi
    
    # Replace original file
    mv "$temp_file" "$file"
    
    local link_count=$(echo "$internal_links" | wc -l | tr -d ' ')
    log_info "Generated $link_count reference-style links in $file"
}

# Main function
main() {
    local target="${1:-.}"
    
    if [[ -f "$target" ]]; then
        # Single file mode
        log_info "Processing: $target"
        process_file "$target"
    elif [[ -d "$target" ]]; then
        # Directory mode
        find "$target" -name "*.md" -type f | while read -r file; do
            log_info "Processing: $file"
            process_file "$file"
        done
    else
        echo "Usage: generate-reference-links [file.md|directory]"
        echo "Examples:"
        echo "  generate-reference-links notes/example.md    # Process single file"
        echo "  generate-reference-links drafts/            # Process all .md files in directory"
        echo "  generate-reference-links                    # Process all .md files in current directory"
        return 1
    fi
}

# If called directly (not sourced), execute the main function with all arguments
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
